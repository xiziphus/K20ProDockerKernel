#!/usr/bin/env python3
"""
Vulnerability Reporter

Generates comprehensive security vulnerability reports based on test results,
including risk assessments, remediation recommendations, and compliance checks.
"""

import os
import sys
import json
import datetime
import hashlib
from typing import Dict, List, Tuple, Optional, Any
from pathlib import Path
from dataclasses import dataclass, asdict

@dataclass
class VulnerabilityFinding:
    """Represents a security vulnerability finding."""
    id: str
    title: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW, INFO
    category: str  # ISOLATION, PRIVILEGE_ESCALATION, BOUNDARY, CONFIGURATION
    description: str
    impact: str
    affected_component: str
    test_name: str
    evidence: Dict[str, Any]
    remediation: str
    references: List[str]
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None

@dataclass
class SecurityReport:
    """Represents a complete security assessment report."""
    report_id: str
    timestamp: str
    system_info: Dict[str, Any]
    test_summary: Dict[str, Any]
    findings: List[VulnerabilityFinding]
    risk_score: float
    compliance_status: Dict[str, Any]
    recommendations: List[str]

class VulnerabilityReporter:
    """Generates security vulnerability reports from test results."""
    
    def __init__(self):
        """Initialize the vulnerability reporter."""
        self.severity_weights = {
            'CRITICAL': 10.0,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 2.5,
            'INFO': 1.0
        }
        
        self.compliance_frameworks = {
            'CIS_DOCKER': 'CIS Docker Benchmark',
            'NIST_800_190': 'NIST SP 800-190',
            'PCI_DSS': 'PCI DSS Container Security',
            'SOC2': 'SOC 2 Security Controls'
        }
    
    def generate_report(self, test_results: List[Dict], system_info: Dict = None) -> SecurityReport:
        """
        Generate comprehensive security report from test results.
        
        Args:
            test_results: List of test result dictionaries
            system_info: System information dictionary
            
        Returns:
            SecurityReport object
        """
        report_id = self._generate_report_id()
        timestamp = datetime.datetime.now().isoformat()
        
        if system_info is None:
            system_info = self._collect_system_info()
        
        # Analyze test results and generate findings
        findings = []
        test_summary = self._generate_test_summary(test_results)
        
        for test_result in test_results:
            test_findings = self._analyze_test_result(test_result)
            findings.extend(test_findings)
        
        # Calculate risk score
        risk_score = self._calculate_risk_score(findings)
        
        # Check compliance status
        compliance_status = self._check_compliance(findings)
        
        # Generate recommendations
        recommendations = self._generate_recommendations(findings)
        
        return SecurityReport(
            report_id=report_id,
            timestamp=timestamp,
            system_info=system_info,
            test_summary=test_summary,
            findings=findings,
            risk_score=risk_score,
            compliance_status=compliance_status,
            recommendations=recommendations
        )
    
    def export_report(self, report: SecurityReport, output_format: str = 'json', 
                     output_file: str = None) -> str:
        """
        Export security report to specified format.
        
        Args:
            report: SecurityReport object
            output_format: Export format ('json', 'html', 'markdown', 'csv')
            output_file: Output file path (optional)
            
        Returns:
            Exported report content or file path
        """
        if output_format.lower() == 'json':
            return self._export_json(report, output_file)
        elif output_format.lower() == 'html':
            return self._export_html(report, output_file)
        elif output_format.lower() == 'markdown':
            return self._export_markdown(report, output_file)
        elif output_format.lower() == 'csv':
            return self._export_csv(report, output_file)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")
    
    def _analyze_test_result(self, test_result: Dict) -> List[VulnerabilityFinding]:
        """Analyze a single test result and generate vulnerability findings."""
        findings = []
        
        if test_result.get('status') == 'FAIL':
            finding = self._create_finding_from_failure(test_result)
            if finding:
                findings.append(finding)
        elif test_result.get('status') == 'ERROR':
            finding = self._create_finding_from_error(test_result)
            if finding:
                findings.append(finding)
        
        # Check for partial failures or warnings in test details
        details = test_result.get('details', {})
        if isinstance(details, dict):
            partial_findings = self._analyze_test_details(test_result, details)
            findings.extend(partial_findings)
        
        return findings
    
    def _create_finding_from_failure(self, test_result: Dict) -> Optional[VulnerabilityFinding]:
        """Create vulnerability finding from failed test."""
        test_name = test_result.get('name', 'Unknown Test')
        message = test_result.get('message', 'Test failed')
        details = test_result.get('details', {})
        
        # Map test names to vulnerability categories and severities
        vulnerability_mapping = {
            'PID Namespace Isolation': {
                'category': 'ISOLATION',
                'severity': 'HIGH',
                'title': 'Container PID Namespace Isolation Failure',
                'description': 'Containers can see processes from other containers or the host system',
                'impact': 'Information disclosure, potential privilege escalation',
                'remediation': 'Ensure proper PID namespace configuration in Docker daemon and kernel'
            },
            'Network Namespace Isolation': {
                'category': 'ISOLATION',
                'severity': 'HIGH',
                'title': 'Container Network Namespace Isolation Failure',
                'description': 'Network isolation between containers is insufficient',
                'impact': 'Network-based attacks between containers, information disclosure',
                'remediation': 'Configure proper network namespace isolation and firewall rules'
            },
            'Capability Drops': {
                'category': 'PRIVILEGE_ESCALATION',
                'severity': 'CRITICAL',
                'title': 'Insufficient Capability Dropping',
                'description': 'Dangerous capabilities are not properly dropped from containers',
                'impact': 'Privilege escalation, system compromise',
                'remediation': 'Configure proper capability dropping in container runtime'
            },
            'User Namespace Restrictions': {
                'category': 'PRIVILEGE_ESCALATION',
                'severity': 'HIGH',
                'title': 'User Namespace Security Bypass',
                'description': 'User namespace restrictions are not properly enforced',
                'impact': 'Privilege escalation, unauthorized access',
                'remediation': 'Enable and configure user namespace mapping properly'
            },
            'SELinux Enforcement': {
                'category': 'BOUNDARY',
                'severity': 'MEDIUM',
                'title': 'SELinux Policy Enforcement Failure',
                'description': 'SELinux policies are not properly enforced for containers',
                'impact': 'Reduced security boundaries, policy bypass',
                'remediation': 'Configure and enable SELinux policies for container workloads'
            },
            'Seccomp Filtering': {
                'category': 'BOUNDARY',
                'severity': 'MEDIUM',
                'title': 'Seccomp System Call Filtering Failure',
                'description': 'System call filtering is not properly configured',
                'impact': 'Unauthorized system calls, potential kernel exploitation',
                'remediation': 'Configure proper seccomp profiles for containers'
            }
        }
        
        mapping = vulnerability_mapping.get(test_name)
        if not mapping:
            # Generic finding for unmapped tests
            mapping = {
                'category': 'CONFIGURATION',
                'severity': 'MEDIUM',
                'title': f'Security Test Failure: {test_name}',
                'description': f'Security test failed: {message}',
                'impact': 'Potential security weakness',
                'remediation': 'Review and fix the identified security issue'
            }
        
        finding_id = self._generate_finding_id(test_name, mapping['severity'])
        
        return VulnerabilityFinding(
            id=finding_id,
            title=mapping['title'],
            severity=mapping['severity'],
            category=mapping['category'],
            description=mapping['description'],
            impact=mapping['impact'],
            affected_component='Container Runtime',
            test_name=test_name,
            evidence=details,
            remediation=mapping['remediation'],
            references=self._get_references_for_category(mapping['category'])
        )
    
    def _create_finding_from_error(self, test_result: Dict) -> Optional[VulnerabilityFinding]:
        """Create vulnerability finding from test error."""
        test_name = test_result.get('name', 'Unknown Test')
        message = test_result.get('message', 'Test error')
        
        finding_id = self._generate_finding_id(test_name, 'LOW')
        
        return VulnerabilityFinding(
            id=finding_id,
            title=f'Security Test Error: {test_name}',
            severity='LOW',
            category='CONFIGURATION',
            description=f'Security test encountered an error: {message}',
            impact='Unable to verify security control',
            affected_component='Test Framework',
            test_name=test_name,
            evidence={'error_message': message},
            remediation='Fix test configuration and re-run security validation',
            references=[]
        )
    
    def _analyze_test_details(self, test_result: Dict, details: Dict) -> List[VulnerabilityFinding]:
        """Analyze test details for additional security issues."""
        findings = []
        test_name = test_result.get('name', 'Unknown Test')
        
        # Check for specific security indicators in test details
        if 'blocked_operations' in details and 'total_operations' in details:
            blocked = details['blocked_operations']
            total = details['total_operations']
            
            if blocked < total:
                # Some operations that should be blocked were allowed
                finding_id = self._generate_finding_id(f"{test_name}_partial", 'MEDIUM')
                findings.append(VulnerabilityFinding(
                    id=finding_id,
                    title=f'Partial Security Control Failure: {test_name}',
                    severity='MEDIUM',
                    category='CONFIGURATION',
                    description=f'Only {blocked} out of {total} security operations were properly blocked',
                    impact='Partial security bypass possible',
                    affected_component='Security Controls',
                    test_name=test_name,
                    evidence=details,
                    remediation='Review and strengthen security control configuration',
                    references=[]
                ))
        
        # Check for privilege escalation indicators
        if any(key in details for key in ['root_switch_blocked', 'shadow_access_blocked']):
            if not details.get('root_switch_blocked', True) or not details.get('shadow_access_blocked', True):
                finding_id = self._generate_finding_id(f"{test_name}_privesc", 'HIGH')
                findings.append(VulnerabilityFinding(
                    id=finding_id,
                    title='Privilege Escalation Risk Detected',
                    severity='HIGH',
                    category='PRIVILEGE_ESCALATION',
                    description='Container may allow privilege escalation to root',
                    impact='Full system compromise possible',
                    affected_component='User Namespace',
                    test_name=test_name,
                    evidence=details,
                    remediation='Configure proper user namespace restrictions and disable setuid binaries',
                    references=self._get_references_for_category('PRIVILEGE_ESCALATION')
                ))
        
        return findings
    
    def _calculate_risk_score(self, findings: List[VulnerabilityFinding]) -> float:
        """Calculate overall risk score based on findings."""
        if not findings:
            return 0.0
        
        total_weight = 0.0
        for finding in findings:
            weight = self.severity_weights.get(finding.severity, 1.0)
            total_weight += weight
        
        # Normalize to 0-100 scale
        max_possible_score = len(findings) * self.severity_weights['CRITICAL']
        if max_possible_score == 0:
            return 0.0
        
        risk_score = (total_weight / max_possible_score) * 100
        return min(risk_score, 100.0)
    
    def _check_compliance(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Check compliance status against security frameworks."""
        compliance_status = {}
        
        for framework, name in self.compliance_frameworks.items():
            # Count findings by category for each framework
            critical_findings = len([f for f in findings if f.severity == 'CRITICAL'])
            high_findings = len([f for f in findings if f.severity == 'HIGH'])
            
            # Determine compliance status
            if critical_findings > 0:
                status = 'NON_COMPLIANT'
                score = 0
            elif high_findings > 2:
                status = 'PARTIALLY_COMPLIANT'
                score = 50
            elif high_findings > 0:
                status = 'MOSTLY_COMPLIANT'
                score = 75
            else:
                status = 'COMPLIANT'
                score = 100
            
            compliance_status[framework] = {
                'name': name,
                'status': status,
                'score': score,
                'critical_findings': critical_findings,
                'high_findings': high_findings
            }
        
        return compliance_status
    
    def _generate_recommendations(self, findings: List[VulnerabilityFinding]) -> List[str]:
        """Generate security recommendations based on findings."""
        recommendations = []
        
        # Group findings by category
        categories = {}
        for finding in findings:
            if finding.category not in categories:
                categories[finding.category] = []
            categories[finding.category].append(finding)
        
        # Generate category-specific recommendations
        if 'ISOLATION' in categories:
            recommendations.append(
                "Strengthen container isolation by reviewing namespace configurations "
                "and ensuring proper separation between containers and host system."
            )
        
        if 'PRIVILEGE_ESCALATION' in categories:
            recommendations.append(
                "Implement strict privilege controls including capability dropping, "
                "user namespace mapping, and removal of setuid binaries."
            )
        
        if 'BOUNDARY' in categories:
            recommendations.append(
                "Configure mandatory access controls (SELinux/AppArmor) and "
                "system call filtering (seccomp) for enhanced security boundaries."
            )
        
        if 'CONFIGURATION' in categories:
            recommendations.append(
                "Review and harden container runtime configuration according to "
                "security best practices and compliance requirements."
            )
        
        # Add general recommendations
        critical_count = len([f for f in findings if f.severity == 'CRITICAL'])
        high_count = len([f for f in findings if f.severity == 'HIGH'])
        
        if critical_count > 0:
            recommendations.insert(0, 
                f"URGENT: Address {critical_count} critical security findings immediately "
                "before deploying containers in production."
            )
        
        if high_count > 0:
            recommendations.append(
                f"Prioritize resolution of {high_count} high-severity security findings "
                "to reduce attack surface."
            )
        
        recommendations.append(
            "Implement continuous security monitoring and regular vulnerability "
            "assessments for container workloads."
        )
        
        return recommendations
    
    def _get_references_for_category(self, category: str) -> List[str]:
        """Get security references for a vulnerability category."""
        references = {
            'ISOLATION': [
                'https://docs.docker.com/engine/security/security/',
                'https://kubernetes.io/docs/concepts/security/pod-security-standards/',
                'https://www.nist.gov/publications/application-container-security-guide'
            ],
            'PRIVILEGE_ESCALATION': [
                'https://docs.docker.com/engine/security/userns-remap/',
                'https://kubernetes.io/docs/concepts/security/pod-security-policy/',
                'https://www.cisecurity.org/benchmark/docker'
            ],
            'BOUNDARY': [
                'https://docs.docker.com/engine/security/apparmor/',
                'https://docs.docker.com/engine/security/seccomp/',
                'https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/using_selinux/index'
            ],
            'CONFIGURATION': [
                'https://www.cisecurity.org/benchmark/docker',
                'https://docs.docker.com/engine/security/',
                'https://kubernetes.io/docs/concepts/security/'
            ]
        }
        
        return references.get(category, [])
    
    def _generate_test_summary(self, test_results: List[Dict]) -> Dict[str, Any]:
        """Generate test execution summary."""
        total_tests = len(test_results)
        passed = len([r for r in test_results if r.get('status') == 'PASS'])
        failed = len([r for r in test_results if r.get('status') == 'FAIL'])
        errors = len([r for r in test_results if r.get('status') == 'ERROR'])
        skipped = len([r for r in test_results if r.get('status') == 'SKIP'])
        
        return {
            'total_tests': total_tests,
            'passed': passed,
            'failed': failed,
            'errors': errors,
            'skipped': skipped,
            'success_rate': (passed / total_tests * 100) if total_tests > 0 else 0
        }
    
    def _collect_system_info(self) -> Dict[str, Any]:
        """Collect system information for the report."""
        import platform
        import subprocess
        
        system_info = {
            'platform': platform.platform(),
            'architecture': platform.architecture()[0],
            'python_version': platform.python_version(),
            'hostname': platform.node()
        }
        
        # Try to get Docker version
        try:
            result = subprocess.run(['docker', '--version'], 
                                  capture_output=True, text=True, check=True)
            system_info['docker_version'] = result.stdout.strip()
        except Exception:
            system_info['docker_version'] = 'Unknown'
        
        # Try to get kernel version
        try:
            result = subprocess.run(['uname', '-r'], 
                                  capture_output=True, text=True, check=True)
            system_info['kernel_version'] = result.stdout.strip()
        except Exception:
            system_info['kernel_version'] = 'Unknown'
        
        return system_info
    
    def _generate_report_id(self) -> str:
        """Generate unique report ID."""
        timestamp = datetime.datetime.now().isoformat()
        hash_input = f"security_report_{timestamp}".encode()
        return hashlib.md5(hash_input).hexdigest()[:12]
    
    def _generate_finding_id(self, test_name: str, severity: str) -> str:
        """Generate unique finding ID."""
        hash_input = f"{test_name}_{severity}".encode()
        return f"VULN-{hashlib.md5(hash_input).hexdigest()[:8].upper()}"
    
    def _export_json(self, report: SecurityReport, output_file: str = None) -> str:
        """Export report as JSON."""
        report_dict = asdict(report)
        json_content = json.dumps(report_dict, indent=2, default=str)
        
        if output_file:
            with open(output_file, 'w') as f:
                f.write(json_content)
            return output_file
        
        return json_content
    
    def _export_markdown(self, report: SecurityReport, output_file: str = None) -> str:
        """Export report as Markdown."""
        md_content = f"""# Security Vulnerability Report

**Report ID:** {report.report_id}  
**Generated:** {report.timestamp}  
**Risk Score:** {report.risk_score:.1f}/100

## Executive Summary

This security assessment identified **{len(report.findings)}** security findings across container isolation, privilege escalation, and security boundary controls.

### Test Summary
- **Total Tests:** {report.test_summary['total_tests']}
- **Passed:** {report.test_summary['passed']}
- **Failed:** {report.test_summary['failed']}
- **Errors:** {report.test_summary['errors']}
- **Success Rate:** {report.test_summary['success_rate']:.1f}%

## Findings by Severity

"""
        
        # Group findings by severity
        severity_groups = {}
        for finding in report.findings:
            if finding.severity not in severity_groups:
                severity_groups[finding.severity] = []
            severity_groups[finding.severity].append(finding)
        
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']:
            if severity in severity_groups:
                md_content += f"### {severity} ({len(severity_groups[severity])} findings)\n\n"
                for finding in severity_groups[severity]:
                    md_content += f"#### {finding.title}\n"
                    md_content += f"**ID:** {finding.id}  \n"
                    md_content += f"**Category:** {finding.category}  \n"
                    md_content += f"**Test:** {finding.test_name}  \n\n"
                    md_content += f"**Description:** {finding.description}\n\n"
                    md_content += f"**Impact:** {finding.impact}\n\n"
                    md_content += f"**Remediation:** {finding.remediation}\n\n"
                    if finding.references:
                        md_content += "**References:**\n"
                        for ref in finding.references:
                            md_content += f"- {ref}\n"
                    md_content += "\n---\n\n"
        
        md_content += "## Recommendations\n\n"
        for i, rec in enumerate(report.recommendations, 1):
            md_content += f"{i}. {rec}\n\n"
        
        md_content += "## Compliance Status\n\n"
        for framework, status in report.compliance_status.items():
            md_content += f"- **{status['name']}:** {status['status']} ({status['score']}%)\n"
        
        if output_file:
            with open(output_file, 'w') as f:
                f.write(md_content)
            return output_file
        
        return md_content
    
    def _export_html(self, report: SecurityReport, output_file: str = None) -> str:
        """Export report as HTML."""
        # Convert markdown to HTML (simplified version)
        md_content = self._export_markdown(report)
        
        html_content = f"""<!DOCTYPE html>
<html>
<head>
    <title>Security Vulnerability Report - {report.report_id}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .critical {{ color: #d32f2f; }}
        .high {{ color: #f57c00; }}
        .medium {{ color: #fbc02d; }}
        .low {{ color: #388e3c; }}
        .info {{ color: #1976d2; }}
        table {{ border-collapse: collapse; width: 100%; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
    </style>
</head>
<body>
    <pre>{md_content}</pre>
</body>
</html>"""
        
        if output_file:
            with open(output_file, 'w') as f:
                f.write(html_content)
            return output_file
        
        return html_content
    
    def _export_csv(self, report: SecurityReport, output_file: str = None) -> str:
        """Export findings as CSV."""
        import csv
        import io
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow([
            'Finding ID', 'Title', 'Severity', 'Category', 'Test Name',
            'Description', 'Impact', 'Remediation', 'Affected Component'
        ])
        
        # Write findings
        for finding in report.findings:
            writer.writerow([
                finding.id, finding.title, finding.severity, finding.category,
                finding.test_name, finding.description, finding.impact,
                finding.remediation, finding.affected_component
            ])
        
        csv_content = output.getvalue()
        output.close()
        
        if output_file:
            with open(output_file, 'w') as f:
                f.write(csv_content)
            return output_file
        
        return csv_content


if __name__ == "__main__":
    # Example usage
    reporter = VulnerabilityReporter()
    
    # Sample test results
    sample_results = [
        {
            'name': 'PID Namespace Isolation',
            'status': 'FAIL',
            'message': 'PID namespace isolation failed',
            'details': {'container1_processes': 10, 'container2_processes': 8}
        },
        {
            'name': 'Capability Drops',
            'status': 'FAIL',
            'message': 'Some privileged operations succeeded',
            'details': {'blocked_operations': 2, 'total_operations': 3}
        }
    ]
    
    report = reporter.generate_report(sample_results)
    
    print("=== Security Vulnerability Report ===")
    print(f"Report ID: {report.report_id}")
    print(f"Risk Score: {report.risk_score:.1f}/100")
    print(f"Findings: {len(report.findings)}")
    
    # Export to different formats
    json_report = reporter.export_report(report, 'json')
    print(f"\nJSON Report Length: {len(json_report)} characters")
    
    md_report = reporter.export_report(report, 'markdown')
    print(f"Markdown Report Length: {len(md_report)} characters")